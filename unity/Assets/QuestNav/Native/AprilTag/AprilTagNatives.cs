using System;
using System.Runtime.InteropServices;

namespace QuestNav.Native.AprilTag
{
    [StructLayout(LayoutKind.Sequential)]
    public struct Point2D
    {
        public double x;
        public double y;

        public override string ToString()
        {
            return $"X: {x},Y: {y}";
        }
    }

    /// <summary>
    /// Represents coordinates of a AprilTag detection
    /// </summary>
    /// <code>
    /// struct quad
    /// {
    ///     float p[4][2]; // corners
    ///     bool reversed_border;
    ///
    ///     // H: tag coordinates ([-1,1] at the black corners) to pixels
    ///     // Hinv: pixels to tag
    ///     matd_t *H, *Hinv;
    /// };
    /// </code>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct QuadNative
    {
        public Point2D corner0; // p[0], p[1]
        public Point2D corner1; // p[2], p[3]
        public Point2D corner2; // p[4], p[5]
        public Point2D corner3; // p[6], p[7]

        [MarshalAs(UnmanagedType.I1)]
        public bool reversed_border;

        public IntPtr H;
        public IntPtr Hinv;
    }

    /// <summary>
    /// Represents a tag family. Every tag belongs to a tag family. Tag
    /// families are generated by the Java tool
    /// april.tag.TagFamilyGenerator and can be converted to C using
    /// april.tag.TagToC.
    /// </summary>
    /// <code>
    /// struct apriltag_family
    /// {
    ///     // How many codes are there in this tag family?
    ///     uint32_t ncodes;
    ///
    ///     // The codes in the family.
    ///     uint64_t *codes;
    ///
    ///     int width_at_border;
    ///     int total_width;
    ///     bool reversed_border;
    ///
    ///     // The bit locations.
    ///     uint32_t nbits;
    ///     uint32_t *bit_x;
    ///     uint32_t *bit_y;
    ///
    ///     // minimum hamming distance between any two codes. (e.g. 36h11 => 11)
    ///     uint32_t h;
    ///
    ///     // a human-readable name, e.g., "tag36h11"
    ///     char *name;
    ///
    ///     // some detector implementations may preprocess codes in order to
    ///     // accelerate decoding.  They put their data here. (Do not use the
    ///     // same apriltag_family instance in more than one implementation)
    ///     void *impl;
    /// };
    /// </code>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct AprilTagFamilyNative
    {
        public uint ncodes;
        public IntPtr codes;
        public int width_at_border;
        public int total_width;

        [MarshalAs(UnmanagedType.I1)]
        public bool reversed_border;
        public uint nbits;
        public IntPtr bit_x;
        public IntPtr bit_y;
        public uint h;

        public IntPtr name;
        public IntPtr impl;
    }

    /// <summary>
    /// Parameters for quad detection threshold processing
    /// </summary>
    /// <code>
    /// struct apriltag_quad_thresh_params
    /// {
    ///     // reject quads containing too few pixels
    ///     int min_cluster_pixels;
    ///
    ///     // how many corner candidates to consider when segmenting a group
    ///     // of pixels into a quad.
    ///     int max_nmaxima;
    ///
    ///     // Reject quads where pairs of edges have angles that are close to
    ///     // straight or close to 180 degrees. Zero means that no quads are
    ///     // rejected. (In radians).
    ///     float critical_rad;
    ///     float cos_critical_rad;
    ///
    ///     // When fitting lines to the contours, what is the maximum mean
    ///     // squared error allowed?  This is useful in rejecting contours
    ///     // that are far from being quad shaped; rejecting these quads "early"
    ///     // saves expensive decoding processing.
    ///     float max_line_fit_mse;
    ///
    ///     // When we build our model of black & white pixels, we add an
    ///     // extra check that the white model must be (overall) brighter
    ///     // than the black model.  How much brighter? (in pixel values,
    ///     // [0,255]). .
    ///     int min_white_black_diff;
    ///
    ///     // should the thresholded image be deglitched? Only useful for
    ///     // very noisy images
    ///     int deglitch;
    /// };
    /// </code>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct ApriltagQuadThreshParamsNative
    {
        // reject quads containing too few pixels
        public int min_cluster_pixels;

        // how many corner candidates to consider when segmenting a group
        // of pixels into a quad.
        public int max_nmaxima;

        // Reject quads where pairs of edges have angles that are close to
        // straight or close to 180 degrees. Zero means that no quads are
        // rejected. (In radians).
        public float critical_rad;
        public float cos_critical_rad;

        // When fitting lines to the contours, what is the maximum mean
        // squared error allowed?  This is useful in rejecting contours
        // that are far from being quad shaped; rejecting these quads "early"
        // saves expensive decoding processing.
        public float max_line_fit_mse;

        // When we build our model of black & white pixels, we add an
        // extra check that the white model must be (overall) brighter
        // than the black model.  How much brighter? (in pixel values,
        // [0,255]).
        public int min_white_black_diff;

        // should the thresholded image be deglitched? Only useful for
        // very noisy images
        public int deglitch;
    }

    /// <summary>
    /// Represents a detector object. Upon creating a detector, all fields
    /// are set to reasonable values, but can be overridden by accessing
    /// these fields.
    /// </summary>
    /// <code>
    /// struct apriltag_detector
    /// {
    ///     ///////////////////////////////////////////////////////////////
    ///     // User-configurable parameters.
    ///
    ///     // How many threads should be used?
    ///     int nthreads;
    ///
    ///     // detection of quads can be done on a lower-resolution image,
    ///     // improving speed at a cost of pose accuracy and a slight
    ///     // decrease in detection rate. Decoding the binary payload is
    ///     // still done at full resolution. .
    ///     float quad_decimate;
    ///
    ///     // What Gaussian blur should be applied to the segmented image
    ///     // (used for quad detection?)  Parameter is the standard deviation
    ///     // in pixels.  Very noisy images benefit from non-zero values
    ///     // (e.g. 0.8).
    ///     float quad_sigma;
    ///
    ///     // When true, the edges of the each quad are adjusted to "snap
    ///     // to" strong gradients nearby. This is useful when decimation is
    ///     // employed, as it can increase the quality of the initial quad
    ///     // estimate substantially. Generally recommended to be on (true).
    ///     //
    ///     // Very computationally inexpensive. Option is ignored if
    ///     // quad_decimate = 1.
    ///     bool refine_edges;
    ///
    ///     // How much sharpening should be done to decoded images? This
    ///     // can help decode small tags but may or may not help in odd
    ///     // lighting conditions or low light conditions.
    ///     //
    ///     // The default value is 0.25.
    ///     double decode_sharpening;
    ///
    ///     // When true, write a variety of debugging images to the
    ///     // current working directory at various stages through the
    ///     // detection process. (Somewhat slow).
    ///     bool debug;
    ///
    ///     struct apriltag_quad_thresh_params qtp;
    ///
    ///     ///////////////////////////////////////////////////////////////
    ///     // Statistics relating to last processed frame
    ///     timeprofile_t *tp;
    ///
    ///     uint32_t nedges;
    ///     uint32_t nsegments;
    ///     uint32_t nquads;
    ///
    ///     ///////////////////////////////////////////////////////////////
    ///     // Internal variables below
    ///
    ///     // Not freed on apriltag_destroy; a tag family can be shared
    ///     // between multiple users. The user should ultimately destroy the
    ///     // tag family passed into the constructor.
    ///     zarray_t *tag_families;
    ///
    ///     // Used to manage multi-threading.
    ///     workerpool_t *wp;
    ///
    ///     // Used for thread safety.
    ///     pthread_mutex_t mutex;
    /// };
    /// </code>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct AprilTagDetectorNative
    {
        ///////////////////////////////////////////////////////////////
        // User-configurable parameters.

        // How many threads should be used?
        public int nthreads;

        // detection of quads can be done on a lower-resolution image,
        // improving speed at a cost of pose accuracy and a slight
        // decrease in detection rate. Decoding the binary payload is
        // still done at full resolution. .
        public float quad_decimate;

        // What Gaussian blur should be applied to the segmented image
        // (used for quad detection?)  Parameter is the standard deviation
        // in pixels.  Very noisy images benefit from non-zero values
        // (e.g. 0.8).
        public float quad_sigma;

        // When true, the edges of the each quad are adjusted to "snap
        // to" strong gradients nearby. This is useful when decimation is
        // employed, as it can increase the quality of the initial quad
        // estimate substantially. Generally recommended to be on (true).
        //
        // Very computationally inexpensive. Option is ignored if
        // quad_decimate = 1.
        [MarshalAs(UnmanagedType.I1)]
        public bool refine_edges;

        // How much sharpening should be done to decoded images? This
        // can help decode small tags but may or may not help in odd
        // lighting conditions or low light conditions.
        //
        // The default value is 0.25.
        public double decode_sharpening;

        // When true, write a variety of debugging images to the
        // current working directory at various stages through the
        // detection process. (Somewhat slow).
        [MarshalAs(UnmanagedType.I1)]
        public bool debug;

        public ApriltagQuadThreshParamsNative qtp;

        ///////////////////////////////////////////////////////////////
        // Statistics relating to last processed frame
        public IntPtr tp;

        public uint nedges;
        public uint nsegments;
        public uint nquads;

        ///////////////////////////////////////////////////////////////
        // Internal variables below

        // Not freed on apriltag_destroy; a tag family can be shared
        // between multiple users. The user should ultimately destroy the
        // tag family passed into the constructor.
        public IntPtr tag_families;

        // Used to manage multi-threading.
        public IntPtr wp;

        // Used for thread safety. Technically platform dependent size in native code, so
        // alloc 64 bytes to be safe.
        public fixed byte mutex[64];
    }

    /// <summary>
    /// Represents the detection of a tag. These are returned to the user
    /// and must be individually destroyed by the user.
    /// </summary>
    /// <code>
    /// struct apriltag_detection
    /// {
    ///     // a pointer for convenience. not freed by apriltag_detection_destroy.
    ///     apriltag_family_t *family;
    ///
    ///     // The decoded ID of the tag
    ///     int id;
    ///
    ///     // How many error bits were corrected? Note: accepting large numbers of
    ///     // corrected errors leads to greatly increased false positive rates.
    ///     // NOTE: As of this implementation, the detector cannot detect tags with
    ///     // a hamming distance greater than 2.
    ///     int hamming;
    ///
    ///     // A measure of the quality of the binary decoding process: the
    ///     // average difference between the intensity of a data bit versus
    ///     // the decision threshold. Higher numbers roughly indicate better
    ///     // decodes. This is a reasonable measure of detection accuracy
    ///     // only for very small tags-- not effective for larger tags (where
    ///     // we could have sampled anywhere within a bit cell and still
    ///     // gotten a good detection.)
    ///     float decision_margin;
    ///
    ///     // The 3x3 homography matrix describing the projection from an
    ///     // "ideal" tag (with corners at (-1,1), (1,1), (1,-1), and (-1,
    ///     // -1)) to pixels in the image. This matrix will be freed by
    ///     // apriltag_detection_destroy.
    ///     matd_t *H;
    ///
    ///     // The center of the detection in image pixel coordinates.
    ///     double c[2];
    ///
    ///     // The corners of the tag in image pixel coordinates. These always
    ///     // wrap counter-clock wise around the tag.
    ///     double p[4][2];
    /// };
    /// </code>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct AprilTagDetectionNative
    {
        // a pointer for convenience. not freed by apriltag_detection_destroy.
        public IntPtr family;

        // The decoded ID of the tag
        public int id;

        // How many error bits were corrected? Note: accepting large numbers of
        // corrected errors leads to greatly increased false positive rates.
        // NOTE: As of this implementation, the detector cannot detect tags with
        // a hamming distance greater than 2.
        public int hamming;

        // A measure of the quality of the binary decoding process: the
        // average difference between the intensity of a data bit versus
        // the decision threshold. Higher numbers roughly indicate better
        // decodes. This is a reasonable measure of detection accuracy
        // only for very small tags-- not effective for larger tags (where
        // we could have sampled anywhere within a bit cell and still
        // gotten a good detection.)
        public float decision_margin;

        // The 3x3 homography matrix describing the projection from an
        // "ideal" tag (with corners at (-1,1), (1,1), (1,-1), and (-1,
        // -1)) to pixels in the image. This matrix will be freed by
        // apriltag_detection_destroy.
        public IntPtr H;

        // The center of the detection in image pixel coordinates.
        public Point2D center; // c[2]

        // The corners of the tag in image pixel coordinates. These always
        // wrap counter-clock wise around the tag.
        public Point2D corner0; // p[0], p[1]
        public Point2D corner1; // p[2], p[3]
        public Point2D corner2; // p[4], p[5]
        public Point2D corner3; // p[6], p[7]
    }

    /// <summary>
    /// Information needed for pose estimation of an AprilTag detection
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct ApriltagDetectionInfoNative
    {
        // Pointer to the detection struct
        public IntPtr det; // apriltag_detection_t* det

        // Tag size in meters
        public double tagsize;

        // Camera intrinsic parameters (in pixels)
        public double fx; // Focal length X
        public double fy; // Focal length Y
        public double cx; // Principal point X
        public double cy; // Principal point Y
    }

    /// <summary>
    /// Represents the pose (position and orientation) of a detected AprilTag
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct AprilTagPoseNative
    {
        public IntPtr R; // Rotation matrix 3x3 of doubles.
        public IntPtr t; // Translation matrix 3x1 of doubles.
    }

    /// <summary>
    /// Represents a integer image
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct ImageU8Native
    {
        /// <summary>
        /// The width of the image in pixels
        /// </summary>
        public int width;

        /// <summary>
        /// The height of the image in pixels
        /// </summary>
        public int height;

        /// <summary>
        /// Number of bytes per row (usually >= width)
        /// </summary>
        public int stride;

        /// <summary>
        /// Pointer to the raw pixel data buffer
        /// </summary>
        public IntPtr buf;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct PjpegNative
    {
        // status of the decode is put here. Non-zero means error.
        public int error;

        public uint width,
            height; // pixel dimensions

        public int ncomponents;
        public IntPtr components;
    }

    /// <summary>
    /// zarray structure layout
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct ZArrayNative
    {
        public IntPtr el_sz; // size_t - size of each element
        public int size; // number of elements
        public int alloc; // allocated capacity
        public IntPtr data; // pointer to data
    }

    /// <summary>
    /// Methods that invoke native code with the apriltag system
    /// </summary>
    public unsafe class AprilTagNatives
    {
        /// <summary>
        /// Creates a new AprilTag detector with default parameters.
        /// Don't forget to add a family!
        /// </summary>
        /// <returns>Pointer to the created apriltag_detector_t</returns>
        /// <code>
        /// apriltag_detector_t *apriltag_detector_create();
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern AprilTagDetectorNative* apriltag_detector_create();

        /// <summary>
        /// Add a family to the apriltag detector. Caller still "owns" the family.
        /// A single instance should only be provided to one apriltag detector instance.
        /// </summary>
        /// <param name="td">The detector to add the family to</param>
        /// <param name="fam">The tag family to add</param>
        /// <param name="bits_corrected">Number of error correction bits</param>
        /// <code>
        /// void apriltag_detector_add_family_bits(apriltag_detector_t *td, apriltag_family_t *fam, int bits_corrected);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void apriltag_detector_add_family_bits(
            AprilTagDetectorNative* td,
            AprilTagFamilyNative* fam,
            int bits_corrected
        );

        /// <summary>
        /// Remove a family from the apriltag detector.
        /// Does not deallocate the family.
        /// </summary>
        /// <param name="td">The detector to remove the family from</param>
        /// <param name="fam">The tag family to remove</param>
        /// <code>
        /// void apriltag_detector_remove_family(apriltag_detector_t *td, apriltag_family_t *fam);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void apriltag_detector_remove_family(
            AprilTagDetectorNative* td,
            AprilTagFamilyNative* fam
        );

        /// <summary>
        /// Unregister all families from the detector, but does not deallocate the underlying tag family objects.
        /// </summary>
        /// <param name="td">The detector to clear families from</param>
        /// <code>
        /// void apriltag_detector_clear_families(apriltag_detector_t *td);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void apriltag_detector_clear_families(AprilTagDetectorNative* td);

        /// <summary>
        /// Destroy the april tag detector (but not the underlying
        /// apriltag_family_t used to initialize it.)
        /// </summary>
        /// <param name="td">The detector to destroy</param>
        /// <code>
        /// void apriltag_detector_destroy(apriltag_detector_t *td);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void apriltag_detector_destroy(AprilTagDetectorNative* td);

        /// <summary>
        /// Detect tags from an image and return an array of apriltag_detection_t*.
        /// You can use apriltag_detections_destroy to free the array and the detections it contains,
        /// or call _detection_destroy and zarray_destroy yourself.
        /// </summary>
        /// <param name="td">The detector to use</param>
        /// <param name="imOrig">The image to process</param>
        /// <returns>zarray_t* containing apriltag_detection_t* elements</returns>
        /// <code>
        /// zarray_t *apriltag_detector_detect(apriltag_detector_t *td, image_u8_t *im_orig);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern ZArrayNative* apriltag_detector_detect(
            AprilTagDetectorNative* td,
            ImageU8Native* imOrig
        );

        /// <summary>
        /// Call this method on each of the tags returned by apriltag_detector_detect
        /// to free the memory associated with the detection.
        /// </summary>
        /// <param name="det">The detection to destroy</param>
        /// <code>
        /// void apriltag_detection_destroy(apriltag_detection_t *det);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void apriltag_detection_destroy(AprilTagDetectionNative* det);

        /// <summary>
        /// Destroys the array AND the detections within it.
        /// </summary>
        /// <param name="detections">The zarray_t* containing detections to destroy</param>
        /// <code>
        /// void apriltag_detections_destroy(zarray_t *detections);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void apriltag_detections_destroy(ZArrayNative* detections);

        /// <summary>
        /// Renders the apriltag to an image.
        /// Caller is responsible for calling image_u8_destroy on the returned image.
        /// </summary>
        /// <param name="fam">The tag family</param>
        /// <param name="idx">The tag index within the family</param>
        /// <returns>image_u8_t* containing the rendered tag</returns>
        /// <code>
        /// image_u8_t *apriltag_to_image(apriltag_family_t *fam, uint32_t idx);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern ImageU8Native* apriltag_to_image(AprilTagFamilyNative* fam, uint idx);

        /// <summary>
        /// Estimates the pose of a detected AprilTag given camera intrinsic parameters and tag size.
        /// </summary>
        /// <param name="info">Pointer to ApriltagDetectionInfo struct containing detection data and camera parameters</param>
        /// <param name="pose">Pointer to AprilTagPose struct where the estimated pose will be stored</param>
        /// <returns>The reprojection error of the pose estimation</returns>
        /// <code>
        /// double estimate_tag_pose(apriltag_detection_info_t *info, apriltag_pose_t *pose);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern double estimate_tag_pose(
            ApriltagDetectionInfoNative* info,
            AprilTagPoseNative* pose
        );

        /// <summary>
        /// Creates a new tag36h11 family instance.
        /// The tag36h11 family contains 587 tags with 11-bit error correction.
        /// Caller is responsible for destroying the family with tag36h11_destroy.
        /// </summary>
        /// <returns>Pointer to the created apriltag_family_t for tag36h11</returns>
        /// <code>
        /// apriltag_family_t *tag36h11_create();
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern AprilTagFamilyNative* tag36h11_create();

        /// <summary>
        /// Destroys a tag36h11 family instance and frees associated memory.
        /// </summary>
        /// <param name="tf">Pointer to the tag36h11 family to destroy</param>
        /// <code>
        /// void tag36h11_destroy(apriltag_family_t *tf);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void tag36h11_destroy(AprilTagFamilyNative* tf);

        /// <summary>
        /// Creates a pjpeg object from a standard JPG input
        /// </summary>
        /// <param name="buf">A pointer to a buffer containing the JPEG image data (in bytes)</param>
        /// <param name="buflen">The length/size of the buffer in bytes</param>
        /// <param name="flags">Configuration flags that control how the JPEG is processed</param>
        /// <param name="error">A pointer to an integer for error codes</param>
        /// <code>
        /// pjpeg_t *pjpeg_create_from_buffer(uint8_t *buf, int buflen, uint32_t flags, int *error);
        /// </code>
        /// <returns>
        /// A pointer to the pjpeg_t object, an error code if available.
        /// </returns>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern PjpegNative* pjpeg_create_from_buffer(
            IntPtr buf,
            int buflen,
            uint flags,
            out PjpegError error
        );

        /// <summary>
        /// Destroys a pjpeg_t object from memory
        /// </summary>
        /// <param name="pj">A pointer to the object to destroy</param>
        /// <code>
        /// void pjpeg_destroy(pjpeg_t *pj);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void pjpeg_destroy(PjpegNative* pj);

        /// <summary>
        /// Error codes that can be returned from converting a JPG to a pjpeg
        /// </summary>
        public enum PjpegError
        {
            /// <summary>
            /// Everything is OK
            /// </summary>
            PJPEG_OKAY = 0,

            /// <summary>
            /// Something wrong reading file
            /// </summary>
            PJPEG_ERR_FILE,

            /// <summary>
            /// Something wrong with DQT marker
            /// </summary>
            PJPEG_ERR_DQT,

            /// <summary>
            /// Something wrong with SOF marker
            /// </summary>
            PJPEG_ERR_SOF,

            /// <summary>
            /// Something wrong with DHT marker
            /// </summary>
            PJPEG_ERR_DHT,

            /// <summary>
            /// Something wrong with SOS marker
            /// </summary>
            PJPEG_ERR_SOS,

            /// <summary>
            /// Missing a necessary huffman table
            /// </summary>
            PJPEG_ERR_MISSING_DHT,

            /// <summary>
            /// Something wrong with DRI marker
            /// </summary>
            PJPEG_ERR_DRI,

            /// <summary>
            /// Didn't get a reset marker where we expected.  Corruption?
            /// </summary>
            PJPEG_ERR_RESET,

            /// <summary>
            /// Ran out of bytes while decoding
            /// </summary>
            PJPEG_ERR_EOF,

            /// <summary>
            /// An unsupported format
            /// </summary>
            PJEPG_ERR_UNSUPPORTED,
        };

        /// <summary>
        /// Converts a decoded JPEG image into a grayscale image by extracting the first component.
        /// </summary>
        /// <param name="pj">The pjpeg pointer</param>
        /// <returns>An image_u8_t of the converted grayscale image</returns>
        /// <code>
        /// image_u8_t *pjpeg_to_u8_baseline(pjpeg_t *pj);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern ImageU8Native* pjpeg_to_u8_baseline(PjpegNative* pj);

        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        internal static extern ImageU8Native* image_u8_create(int width, int height);

        /// <summary>
        /// Destroys a image_u8 object
        /// </summary>
        /// <param name="im">The image_u8 pointer</param>
        /// <code>
        /// void image_u8_destroy(image_u8_t *im);
        /// </code>
        [DllImport("apriltag", CallingConvention = CallingConvention.Cdecl)]
        public static extern void image_u8_destroy(ImageU8Native* im);

        /// <summary>
        /// Retrieves the number of elements currently being contained by the passed
        /// array, which may be different from its capacity. The index of the last element
        /// in the array will be one less than the returned value.
        /// THIS IS NOT A PINVOKE CALL, rather a wrapper that calls a non-inline method
        /// </summary>
        /// <param name="za">Pointer to the array</param>
        /// <returns>Size of the array</returns>
        /// <code>
        /// static inline int zarray_size(const zarray_t *za);
        /// </code>
        /// <summary>
        /// Gets the number of elements in a zarray.
        /// </summary>
        public static int zarray_size(ZArrayNative* za)
        {
            if (za == null)
                return 0;

            return za->size;
        }

        /// <summary>
        /// Retrieves the element from the supplied array located at the zero-based
        /// index of 'idx' and copies its value into the variable pointed to by the pointer
        /// 'p'.
        /// THIS IS NOT A PINVOKE CALL, rather a wrapper that calls a non-inline method
        /// </summary>
        /// <param name="za">Pointer to the array</param>
        /// <param name="idx">ID of the element to get</param>
        /// <param name="p">pointer to the output of the method (in this case, always a pointer)</param>
        /// <code>
        /// static inline void zarray_get(const zarray_t *za, int idx, void *p)
        /// </code>
        public static void zarray_get(ZArrayNative* za, int idx, out IntPtr p)
        {
            ZArrayNative* arr = (ZArrayNative*)za;

            // zarray stores elements contiguously, each of size el_sz
            // For detection arrays, el_sz is sizeof(pointer), and we want to read that pointer
            long elSize = arr->el_sz.ToInt64();
            IntPtr elementAddr = IntPtr.Add(arr->data, idx * (int)elSize);

            // Read the pointer at that location
            p = *(IntPtr*)elementAddr;
        }
    }
}
